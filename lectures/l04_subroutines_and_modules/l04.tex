\input{../common}
\title{Programming Techniques}
\subtitle{Lecture 4: programs, modules, subroutines, and functions}
\author{Hannu Parviainen}
\date{\today}

\begin{document}

% Title
\begin{frame}
  \titlepage
\end{frame}

\section{Program Units}

\begin{frame}{Fortran 90 Program Units}
  \begin{block}{Main kinds}
    \begin{itemize}
      \item \textbf{program}: where execution begins; may contain internal procedures via \texttt{contains}.
      \item \textbf{module}: container of declarations and procedures; attach with \texttt{use}.
    \end{itemize}
  \end{block}
  \begin{block}{Procedures}
    \begin{itemize}
      \item \textbf{subroutine}: performs a task; invoked with \texttt{call}; no return value.
      \item \textbf{function}: like a subroutine but returns a value via its function name.
    \end{itemize}
  \end{block}
\end{frame}

\section{Main Program}

\begin{frame}[fragile]{Main Program: Syntax}
\begin{block}{Skeleton}
\begin{lstlisting}[language=Fortran]
program Main
  implicit none
  ! declarations
  ! executable statements
contains                 ! optional internal procedures
  ! subroutine ...
  ! function   ...
end program Main
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Main Program: Minimal Example}
\begin{block}{Internal function example}
\begin{lstlisting}[language=Fortran]
program main
  implicit none
  real :: x
  read *, x
  print *, floor(x)            ! intrinsic
  print *, negative(x)         ! internal function
contains
  real function negative(a)
    real, intent(in) :: a
    negative = -a
  end function negative
end program main
\end{lstlisting}
\end{block}
\end{frame}


\section{Modules}

\begin{frame}[fragile]{Modules}
  \begin{columns}[T]
    % Left: text
    \column{0.52\textwidth}
    \begin{block}{What modules are}
      \begin{itemize}
        \item Libraries of functions, subroutines, derived types, and constants.
        \item Can live in the same file as the main program, but are typically in their own files.
        \item Can be precompiled and linked with the main program at compilation time.
      \end{itemize}
    \end{block}
    \vspace{0.3em}

    \column{0.48\textwidth}
\begin{lstlisting}[language=Fortran]
module mymath
  implicit none
  real, parameter :: pi = 3.14
contains
  real function square(a)
    real, intent(in) :: a
    square = a**2
  end function square
end module mymath

program ex1
  use mymath
  implicit none
  print *, square(2.3), pi
end program ex1
\end{lstlisting}
    \end{columns}
\end{frame}


\begin{frame}[fragile]{Compiling a program that uses a module}
  \begin{columns}[T]
    \column{0.52\textwidth}
    \begin{block}{Compilation result}
      \begin{itemize}
        \item Compiling the example produces the executable \texttt{ex1} and a module file \texttt{mymath.mod}.
        \item The \texttt{.mod} file plays a role similar to a C/C++ header: it contains interface information for procedures in the module.
      \end{itemize}
    \end{block}

    \column{0.48\textwidth}
\begin{lstlisting}[language=bash]
gfortran -o ex1 ex1.f90
\end{lstlisting}

\begin{lstlisting}[language=Fortran]
module mymath
  implicit none
  real, parameter :: pi = 3.14
contains
  real function square(a)
    real, intent(in) :: a
    square = a**2
  end function square
end module mymath

program ex1
  use mymath
  implicit none
  print *, square(2.3), pi
end program ex1
\end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Modules in separate files \& build options}
  \begin{columns}[T]
    \column{0.52\textwidth}
    \begin{block}{Two-file layout}
      \texttt{mymath.f90} holds the module; \texttt{ex1.f90} holds the program.
    \end{block}
    \begin{block}{Compiling}
      \begin{itemize}
        \item Compile the module first, then link the object when building the program:
        \item[] \texttt{gfortran -c mymath.f90}\\
               \texttt{gfortran -o ex1 ex1.f90 mymath.o}
        \item Or compile both source files together:
        \item[] \texttt{gfortran -o ex1 ex1.f90 mymath.f90}
        \item For larger projects, use a \textbf{Makefile} (covered next lecture).
      \end{itemize}
    \end{block}

    \column{0.48\textwidth}
\begin{lstlisting}[language=Fortran,caption={mymath.f90}]
module mymath
  implicit none
  real, parameter :: pi = 3.14
contains
  real function square(a)
    real, intent(in) :: a
    square = a**2
  end function square
end module mymath
\end{lstlisting}

\begin{lstlisting}[language=Fortran,caption={ex1.f90}]
program ex1
  use mymath
  implicit none
  print *, square(2.3), pi
end program ex1
\end{lstlisting}
  \end{columns}
\end{frame}



\section{Subroutines}

\begin{frame}[fragile]{Subroutines: Syntax and Example}
  \begin{block}{General form}
\begin{lstlisting}[language=Fortran]
subroutine ProcName(dummy_args)
  ! declare dummy arguments
  ! local declarations
  ! executable statements
end subroutine ProcName
\end{lstlisting}
  \end{block}
  \begin{block}{Internal subroutine inside a program}
\begin{lstlisting}[language=Fortran]
program Thingy
  implicit none
  call OutputFigures(NumberSet)
contains
  subroutine OutputFigures(Numbers)
    real, dimension(:), intent(in) :: Numbers
    print *, "Here are the figures", Numbers
  end subroutine OutputFigures
end program Thingy
\end{lstlisting}
  \end{block}
\end{frame}

\section{Functions}

\begin{frame}[fragile]{Functions: Syntax}
\begin{block}{Return via \texttt{result(variable\_name)}}
\begin{lstlisting}[language=Fortran]
function fun(a, b) result(res)
  real intent(in) :: a, b
  real :: res
  res = sqrt(a**2 + b**2)
end function fun
\end{lstlisting}
\end{block}

\begin{block}{Return via function name}
\begin{lstlisting}[language=Fortran]
real function fun(a, b)
  real intent(in) :: a, b
  fun = sqrt(a**2 + b**2)
end function fun
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Recursive Functions}
  \begin{columns}[T]
    \column{0.45\textwidth}
    \begin{block}{Concept}
      \begin{itemize}
        \item Functions that call themselves.
        \item Useful for algorithms defined inductively
              (e.g. factorial, Fibonacci).
        \item Must be declared with the keyword
              \texttt{recursive}.
        \item Must include a termination condition to
              prevent infinite recursion.
      \end{itemize}
    \end{block}

    \column{0.55\textwidth}
    \begin{block}{Example}
\begin{lstlisting}[language=Fortran]
recursive function factorial(n) result(f)
  integer, intent(in) :: n
  integer :: f

  if (n <= 1) then
    f = 1
  else
    f = n * factorial(n - 1)
  end if
end function factorial
\end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Pure Functions}
  \begin{columns}[T]
    \column{0.45\textwidth}
    \begin{block}{Concept}
      \begin{itemize}
        \item Declared with the keyword \texttt{pure}.
        \item No side effects: cannot alter global variables,
              perform I/O, or modify their arguments
              (except via \texttt{intent(out)}).
        \item Always return the same result given the same
              inputs.
        \item Safe for parallel execution.
      \end{itemize}
    \end{block}

    \column{0.55\textwidth}
    \begin{block}{Example}
\begin{lstlisting}[language=Fortran]
pure function fun(x, y) result(r)
  real, intent(in) :: x, y
  real :: r

  r = sqrt(x**2 + y**2)
end function fun
\end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Elemental Functions}
  \begin{columns}[T]
    \column{0.45\textwidth}
    \begin{block}{Concept}
      \begin{itemize}
        \item Declared with the keyword \texttt{elemental}.
        \item Applied element-wise to array arguments.
        \item Arguments must be scalars or conformable arrays.
        \item Very useful for concise array programming.
      \end{itemize}
    \end{block}

    \column{0.55\textwidth}
    \begin{block}{Example}
\begin{lstlisting}[language=Fortran]
module test
  implicit none
contains
elemental real function square(x)
    real, intent(in) :: x
    square = x*x
  end function
end module test

program ex
  use test
  implicit none
  real, dimension(3) :: x = [1.0, 2.0, 3.0]
  print *, square(x)
end program ex
\end{lstlisting}

    \end{block}
  \end{columns}
\end{frame}


\section{Passing Arguments}

\begin{frame}[fragile]{Dummy Arguments and \texttt{intent}}
  \begin{columns}[T]
    % Left column
    \column{0.48\textwidth}
    \begin{block}{Intent attributes}
      \begin{itemize}
        \item \texttt{intent(in)}: argument is read-only inside the procedure.
        \item \texttt{intent(out)}: argument is written (output) by the procedure.
        \item \texttt{intent(inout)}: argument is both read and modified.
      \end{itemize}
      These clarify usage and improve compiler diagnostics.
    \end{block}

    % Right column
    \column{0.52\textwidth}
    \begin{block}{Example}
\begin{lstlisting}[language=Fortran]
subroutine scale(alpha, v)
  real, intent(in)    :: alpha
  real, intent(inout) :: v(:)
  v = alpha * v
end subroutine scale
\end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}


\section{Internal vs Module Procedures}

\begin{frame}{Choosing a Procedure Placement}
  \begin{block}{Internal procedures}
    \begin{itemize}
      \item Defined after \texttt{contains} in a \texttt{program} or \texttt{module}.
      \item Have host association; implicit interface for host variables; great for small helpers tightly coupled to one unit.
    \end{itemize}
  \end{block}
  \begin{block}{Module procedures}
    \begin{itemize}
      \item Reusable across translation units via \texttt{use}; provide explicit interfaces to callers.
      \item Control visibility with \texttt{public}/\texttt{private}.
    \end{itemize}
  \end{block}
\end{frame}


\section{Exercises}
\begin{frame}{Exercises: Modules, Subroutines, and Functions}
	\begin{block}{Tasks}
		\begin{enumerate}
			\item Write a module \texttt{mymath} in a \texttt{mymath.f90} file containing:
			\begin{itemize}
				\item a parameter \texttt{pi = 3.14159},
				\item a function \texttt{circle\_area(r)} that returns the area of a circle.
			\end{itemize}
			\item Create a main program in a \texttt{test\_mymath.f90} file that uses the module and prints the area of a circle with radius 2.0.
			\item Compile and link the module and program
		\end{enumerate}
	\end{block}
\end{frame}


\begin{frame}{Exercises: Recursive Functions}
	\begin{block}{Tasks}
		\begin{enumerate}
			\item Write a recursive function \texttt{factorial(n)} that computes $n!$.
			\item Test the function by computing $5!$ and $10!$.
			\item Modify the function to handle invalid inputs (e.g.\ $n < 0$).
			\item Write a recursive function \texttt{fibonacci(n)} that returns the $n$th Fibonacci number.
			\item Compare the recursive implementation with an iterative one.
		\end{enumerate}
	\end{block}
\end{frame}


\end{document}
